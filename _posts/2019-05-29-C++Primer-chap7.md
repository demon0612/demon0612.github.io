---
layout: post
title: C++ Primer 第七章
categories: C++
description: C++ Primer
keywords: C++, Primer
---

类

---

## 第七章

### 定义抽象数据类型 

- this是一个常量指针，不允许修改this中保存的指针。即this的类型为:class_type \*const，默认情况下不能将this指针绑定到一个常量对象上。

- 如果一个类的函数声明，以const结尾：
```c++
class class_name
{
    void func() const;
}
```
这个const表示this是一个指向常量的指针，即const class_type \* const。
这样的成员函数称为常量成员函数。因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。

- 常量对象，以及常量对象的引用或者指针只能滴啊用常量成员函数。

- 如果需要返回this指针的函数：
```c++
class_type& class_type::func()
{
    return *this;
}
```

- IO函数不能被拷贝，想要使用IO来输出类信息，IO对象必须是引用，而且不能是const引用。

- C++11中如果需要默认的构造函数，可以在参数列表后面加上=default来要求编译器生成构造函数。
```c++
class class_type
{
    class_type()=default;
}
```
默认构造函数想要生效，必须在类内对内置类型提供初始化。如果编译器不支持类内初始化，则只能用函数初始化列表来显式初始化类的每个成员。

### 访问控制与封装

- 使用class和struct定义类唯一的区别就是默认的访问权限：struct默认是public，而class默认是private

- 如果类想把一个函数作为它的友元，则只需要增加一条以friend关键字开始的函数声明语句。友元声明可以出现在类的内部的任意位置。友元不是类的成员，也不受它所在区域控制级别的约束。

- 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么必须在友元声明之外再专门对函数进行一次声明。

### 类的其他特性

- 用来定义类型的成员(typedef或者using)必须先定义后使用，这一点与普通成员有所区别,可以直接静态获得一个定义类型的成员。
- 可以用mutable关键字定义一个可变数据成员，可变数据成员永远不会是const，即使它是const对象的成员。一个const成员函数可以改变一个可变成员的值。

```c++
class class_name
{
    public:
    void func() const;

    private:
    mutable size_t i;
}

void class_name::func() const
{
    ++i;//OK的，mutable在任何函数中都是可变的
}
```
- 当尝试提供一个类内初始值时，必须以等号或者花括号来表示。如果使用default()，则必须保证类中每个成员有默认初始值，尤其对于内置类型。否则要使用列表初始化。

- 一个const成员函数如果以引用的方式返回\*this，则它的返回类型将是常量引用。

- 如果一个类制定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元关系不存在传递关系，每个类负责控制自己的友元类或者友元函数。

- 尽管重载函数的名字先沟通呢个，但是他们仍然是不同的函数，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个都进行声明。

- 友元声明和作用域：类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式的假定该名字在当前作用域中可见，然而，友元本身不一定真的声明在当前作用域。就算是在类的内部定义该友元函数，也必须在类的外部提供相应的声明从而使函数可见。即使仅仅是用声明友元的类的成员函数调用该友元函数，它也必须被声明过。

```c++
struct X
{
    friend void f();//只是说明访问权限，不是普通意义的声明
    X() { f(); }  //错误，f还没有被声明
    void g();
    void h();
};

void X::g() {return f();}   // 错误，f没有被声明。
void f();                   // 声明那个定义在X中的函数
void X::h() {return f();}   // OK，现在f的声明在作用域
```

### 类的作用域

- 如果函数返回类型也是类内定义的类型，则在类外定义函数时，返回类型也要加上类作用域。
```c++
class A
{
    public:
        B add(const A&);
    private:
        class B
        {
        };
};
A::B  A::add(const A& a);//返回类型必须加上作用域。
```

- 类的定义分两步处理：
   - 首先，编译成员的声明
   - 直到类全部可见后才编译函数体
这两个阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前可见。

- 一般来讲，内层作用域可以重新定义外层作用域中的名字。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一个类型，则类不能在之后重新定义该名字：
```c++
typedef double Money;
class Account
{
    public:
        Money balance() {return bal;}   //使用外层作用域
    private:
        typedef double Money;           //错误：不能重新定义Money
        Money bal;
        //...
```
- 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成都出现在类名的定义之后。

### 构造函数再探
- 如果类成员是const，引用或者是属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始化列表为这些成员提供初值。
- 成员初始化顺序不依赖于初始化列表的顺序，而取决于变量在类中的声明顺序。最好令构造函数初始值的顺序与成员声明的顺序保持一致。如果可能的话，尽量避免使用厚些成员初始化其他成员。
- C++11中可以使用委托构造函数，一个委托构造函数使用它所属类的其他构造函数执行自己的初始化过程，例子如下：
```c++
class A
{
    public:
    A(string s, unsigned cnt,double price):_s(s),_cnt(cnt),_price(price){};
    A()::A("",0,0){};
    A(string s)::A(s,0,0){};
}
```
- 隐式的类类型转化，只允许一步。如果要抑制构造函数的隐式转化，可以使用explicit关键词加以阻止。关键字explicit支队一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转化，所以无需将这些构造函数指定为explicit。只需在类内声明构造函数时使用explicit，在类外部定义时不用重复。explicit构造函数不能用于拷贝初始化。

- 聚合类可以使用花括号进行初始化，初始化要注意声明的元素顺序。聚合类满足的条件：
   - 所有成员都是public
   - 没有构造函数
   - 没有类内初始值
   - 没有基类，也没有virtual函数

### 类的静态成员
- static声明静态成员，可以是常量、引用、指针或者类类型
- static函数不与任何对象绑定在一起，不包括this指针，不能声明为const。类外部定义static函数，不需要static关键字。
- static变量可以是const。静态成员可以提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型。
- 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员，只是不需要赋初值。
- 静态成员数据可以是不完整类型，而非静态数据成员不行，只能是所属类的指针或者引用
```c++
class Bar
{
    private:
    static Bar mem1;        //正确，静态成员可以是不完全类型
    Bar* men2;              //正确，指针成员可以是不完全类型
    Bar mem3;               //错误，数据成员必须是完整类型
}
```
- 静态成员可以作为默认实参，而非静态成员不能作为默认实参。














