---
layout: post
title: C++ Primer 第十八章
categories: C++
description: C++ Primer
keywords: C++, Primer
---

用于大行程序的工具

---

## 第十八章

### 异常处理

- C++中通过抛出一条表达式来引发一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码将被用来处理该异常。当执行一个throw时，跟在throw后面的语句将不再被执行。相反，程序的控制权从throw转移到了与之匹配的catch模板。该catch可能是同一个函数中的局部catch，也可能位于直接或者间接低啊用了发生异常的函数的另一个函数中。控制权从一处转移到另一处。

- 栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止。如果一直没有找到匹配的catch，则退出主函数后查找过程终止。

- 如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。如果某个对象是类类型，则该对象的析构函数将会被自动调用。

- 在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。

- 抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。

- 通常情况下，如果catch接受的异常与某个继承体系有关，则最好将该catch的参数定义为引用类型。

- 在搜索catch语句的过程中，我们最终找到的catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。如果在多个catch语句的类型之间存在着继承关系，则我们应该把继承链最底端的类放在前面，而将继承链最顶端的类放在后面。

- 一条catch语句通过重新抛出的操作将异常传递给另外一个catch语句。这里重新抛出仍然是一条throw语句，只不过不包含任何表达式。一个重新抛出语句并不制定新的表达式，只是将当前的异常对象沿着调用链向上传递。

- 如果捕获所有异常catch(...)与其他几个catch语句一起出现，则catch(...)必须在最后的位置。出现在捕获所有异常语句后面的额catch语句将永远不会被匹配。

- 处理构造函数初始值异常的唯一方法是将构造函数写成函数try语句块。

- C++11中可以提供noexcept说明指定某个函数不会抛出异常。
```c++
void recoup(int) noexcept;//不会抛出异常
void alloc(int);//可能会抛出异常
```
noexcept要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该声明应该在尾置返回类型之前。在typedef中不能出现noexcept。在成员函数中，noexcept说明符要跟在const及引用限定符之后，而在final、override活虚函数的=0之前。

- 如果一个函数声明了noexcept，但是函数体内throw了一个异常，编译器可以通过编译。程序直接调用terminate处理抛出异常。指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。

- noexcept运算符是一个一元运算符，返回一个bool类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。
```c++
noexcept(recoup(i);//如果recoup不抛出异常则结果为true，否则结果为false。
void f() noexcept(noexcept(g()));//f和g的异常说明一致，如果g不抛出异常，f也不会抛出异常。反之亦然
```

- noexcept有两层含义：当跟在函数参数列表后面时他是异常说明符，而当做为noexcept异常说明的bool实参出现时，它是一个运算符。

- 函数指针及该指针所指的函数必须具有一致的异常说明。如果我们为某个指针做了不抛出异常的说明，则该指针将只能指向不抛出异常的函数。如果我们现实或者隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使承诺了不抛出异常的函数也可以。

- 如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺。与之相反，如果接力的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。

- 异常类层次如下图：
![异常类层次](/assets/images/chap18-exception.png)

### 命名空间

- 命名空间作用域后面无须分号。
- 命名空间可能是不连续的。例如：
```c++
namespace nsp{
    //...
}
```
如果之前没有名为nsp的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间并为其添加一些新的成员声明。

- 一般情况下，我们不把#include放在命名空间内部。如果这么做了，隐含的意思就是把头文件中所有的名字定义成该命名空间的成员。

- 作用域运算符同样可以用于全局作用域成员，因为全局作用域是隐式的，所以它并没有名字。下面的形式：
```c++
::member_name
```
表示全局命名空间中的一个成员。

- 命名空间可以嵌套，嵌套的命名空间同时是一个嵌套的作用域。

- C++11中引入了内联命名空间，内联命名空间中的名字可以被外层命名空间直接使用。无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。定义内敛命名空间的方法就是在关键字namespace前加上inline。关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写inline也可以不写。

- 未命名的命名空间是指关键字namespace后紧跟花括号括起来的一系列声明语句。未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，直到程序结束才被销毁。

- 一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。未命名的命名空间仅在特定的文件内部有效。其作用范围不会横跨多个不同的文件。

- 在文件中进行静态声明的做法已经被C++标准取消了，现在的做法是使用未命名的命名空间。

- 命名空间别名：
```c++
namespace cplusplus_primer
{
    /*...*/
}
namespace primer = cplusplus_primer;//命名空间别名
```
- using指示：using NS::func；using声明：using namespace NS;

- 头文件如果在其顶层作用域中含有using指示或者using声明，则会将名字注入到所有包含了该头文件的文件中。同文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用usng指示或者using声明。

- 可以从函数的限定名推断出查找名字时检查作用的次序，限定名以相反次序指出被查找的作用域。

- 友元声明与实参相关的查找：
```c++
namespace A
{
    class C
    {
        friend void f2();//除非另有声明，否则不会被找到
        friend void f(const C&);//根据实参相关的查找规则可以被找打
    }
}
```
此时，f和f2都是命名空间A的成员。即使f不存在其他声明，我们也能通过实参相关的查找规则调用f：
```c++
int main()
{
    A::C cobj;
    f(cobj);//正确，通过在A::C中的友元声明找到A::f
    f2();//错误，A::f2没有被声明
}
```
因为f接受一个类类型的实参，而且f在C所属的命名空间进行了隐式的声明，所以f能被找到。相反，f2没有形参，所以它没有办法被找到。

- using声明语句声明的是一个名字，而非一个特定的函数：
```c++
using NF::print(int);//错误：不能指定形参列表
using NF::print;//正确，using声明只声明一个名字
```
一个using声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如果using声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表先沟通，则该using声明将引发错误。除此之外，using声明将引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。

- 与using声明不同的是，对于using指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误。此时，只要指明调用的是命名空间中的函数版本还是当前作用域中的版本即可。


### 多重继承与虚继承

- 派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。

- C++11中允许派生类从它的一个或者几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数(即形参列表完全相同)，则程序将产生错误。

- 编译器不会在派生类向基类的集中转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好。

- 当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。

- 含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。

- 编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反。

