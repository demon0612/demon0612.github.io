---
layout: post
title: C++ Primer 第十五章
categories: C++
description: C++ Primer
keywords: C++, Primer
---

 面向对象程序设计

---

## 第十五章

### 定义基类和派生类

- C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面，或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面跟一个关键字override。

- 每个类控制自己的成员初始化过程。首先初始化基类的部分，然后按照声明的数据依初始化派生类的成员。

- 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。无论从基类中派生出多少个派生类，对于每个静态成员来说，都只存在唯一的实例。

- C++11定义了final关键字，可以防止继承的发生：
```c++
class NoDerived final {/* */};
```

- 继承关系类型之间的转化规则：
   - 从派生类向基类的类型转换只对指针或者引用类型有效。
   - 基类向派生类不存在隐式类型转换。
   - 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

### 虚函数
- 一旦某个函数被声明为虚函数，则所有派生类都是他都是虚函数。一个派生类如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。

- 如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法行为。派生类的函数并没有覆盖掉基类中的版本。使用override参数可以让编译器对某个函数进行检查。如果该函数并没有覆盖已存在的虚函数，此时编译器将报错。

- 如果通过基类的引用或者指针调用函数，则使用积累中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。虚函数的默认实参是静态绑定的。如果虚函数使用了默认实参，则基类和派生类中定义的默认实参最好一致。

- 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

### 访问控制与继承
- 派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。

- 不能继承友元关系，每个类负责控制各自成员的访问权限。

- 通过使用using声明可以改变派生类继承的某个名字的访问级别。
```c++
class Base
{
   public:
   std::size_t size() const {return n;}
   protected:
   std::size_t n;
};
class Derived:private Base
{
   public:
   using Base::size;
   protected:
   using Base::n;
};
```
因为Derived使用了私有继承，所以继承而来的成员size和n是Derived的私有成员。通过using声明之后，Derived的用户可以使用size成员，而Derived的派生类可以使用n。注意：派生类智能为它可以访问的名字提供using声明。如果Base中某个变量是private，则无论以何种方式继承，Derived中都不可能使用using声明。

- class关键字定义的派生类默认是私有继承的，而struct关键字定义的派生类是公有继承的。

### 继承中的类作用域
- 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域之内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

- 派生类的成员将隐藏同名的基类成员。作用域运算符将覆盖掉原来的查找规则。除了覆盖继承而来的虚函数之外，派生类最好不哟啊重用其他定义在基类中的名字。

- 名字查找优于类型检查。声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义派生类中的函数也不会重载其基类中的成员。如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也会被隐藏。
```c++
class Base
{
    public:
    virtual int fcn();
};
class D1:public Base
{
    public:
    int fcn(int);//隐藏基类的fcn，这个fcn不是虚函数。但是可以通过虚函数指针调用基类的fcn()
    virtual void f2();//是一个新的虚函数，在Base中不存在
};
class D2:public D1
{
    public:
    int fcn(int);//非虚函数，隐藏了D1::fcn(int)
    int fcn();//覆盖了Base的虚函数fcn;
    void f2();//覆盖了D1的虚函数f2
};
```
则如下调用：
```c++
//对于fcn的测试
Base* bp1 = new Base();
Base* bp2 = new D1();
Base* bp3 = new D2();
bp1->fcn();//Base::fcn
bp2->fcn();//Base::fcn
bp3->fcn();//D2::fcn
//对于f2的测试
D1* dp1 = new D1();
D1* dp2 = new D2();
bp2->f2();//bp2是一个Base指针，里面没有f2函数
dp1->f2();//D1::f2()
dp2->f2();//D2::f2()
//对于fcn(int)的测试，不是虚函数，不会发生动态绑定 
Base* p1 = new D2();
D1* p2 = new D2();
D2* p3 = new D2();
p1->fcn(42);//错误，Base中没有一个int类型的fcn
p2->fcn(42);//D1:fcn(int)
p3->fcn(42);//D2:fcn(int)
```

### 构造函数与拷贝控制
- 入股基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。

- 之前说过，如果一个类需要析构函数，则它同样需要拷贝和赋值操作。基类的析构函数并不遵循上述操作，这是一个重要例外。

- 基类需要一个虚析构函数，如果一个雷定义了析构函数，即使是通过=default的形式使用了合成的版本，编译器也不能为这个类合成移动操作。

- 当派生类定义了拷贝后者移动操作时，该操作负责拷贝或者移动包括基类部分成员在内的整个对象。

- 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝(或者移动)基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝(或者移动)构造函数。

- 和构造函数以及赋值运算符不同，派生类的析构函数只需要负责销毁由派生类自己分配的资源。

- 在C++11新标准中，派生类能够重用其直接基类定义的构造函数。派生类继承基类构造函数的方式是提供一条注明了基类名的using声明语句。通常情况下，using声明语句只令某个名字在当前作用域可见，而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。

- 一个构造函数的using声明不会改变该构造函数的访问级别。不管using声明在哪儿，基类的私有构造函数在派生类中依然是私有构造函数，受保护的构造函数和共有构造函数也是同样规则。

- 一个using声明不能指定为explicit或者constexpr，如果基类是explicit或者constexpr，则继承构造函数也拥有相同的属性。

### 容器与继承

- 当我们希望在容器中存放具有继承关系的对象时，通常存放的都是基类的指针。








