---
layout: post
title: C++ Primer 第十五章
categories: C++
description: C++ Primer
keywords: C++, Primer
---

 面向对象程序设计

---

## 第十五章

### 定义基类和派生类

- C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面，或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面跟一个关键字override。

- 每个类控制自己的成员初始化过程。首先初始化基类的部分，然后按照声明的数据依初始化派生类的成员。

- 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。无论从基类中派生出多少个派生类，对于每个静态成员来说，都只存在唯一的实例。

- C++11定义了final关键字，可以防止继承的发生：
```c++
class NoDerived final {/* */};
```

- 继承关系类型之间的转化规则：
   - 从派生类向基类的类型转换只对指针或者引用类型有效。
   - 基类向派生类不存在隐式类型转换。
   - 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。

### 虚函数
- 一旦某个函数被声明为虚函数，则所有派生类都是他都是虚函数。一个派生类如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。

- 如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法行为。派生类的函数并没有覆盖掉基类中的版本。使用override参数可以让编译器对某个函数进行检查。如果该函数并没有覆盖已存在的虚函数，此时编译器将报错。

- 如果通过基类的引用或者指针调用函数，则使用积累中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。虚函数的默认实参是静态绑定的。如果虚函数使用了默认实参，则基类和派生类中定义的默认实参最好一致。

- 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

### 访问控制与继承
- 派生类的成员或者友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。

- 不能继承友元关系，每个类负责控制各自成员的访问权限。

- 通过使用using声明可以改变派生类继承的某个名字的访问级别。
```c++
class Base
{
   public:
   std::size_t size() const {return n;}
   protected:
   std::size_t n;
};
class Derived:private Base
{
   public:
   using Base::size;
   protected:
   using Base::n;
};
```
因为Derived使用了私有继承，所以继承而来的成员size和n是Derived的私有成员。通过using声明之后，Derived的用户可以使用size成员，而Derived的派生类可以使用n。注意：派生类智能为它可以访问的名字提供using声明。如果Base中某个变量是private，则无论以何种方式继承，Derived中都不可能使用using声明。

- class关键字定义的派生类默认是私有继承的，而struct关键字定义的派生类是公有继承的。

### 继承中的类作用域

