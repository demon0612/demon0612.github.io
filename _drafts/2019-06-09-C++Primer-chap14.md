---
layout: post
title: C++ Primer 第十四章
categories: C++
description: C++ Primer
keywords: C++, Primer
---

重载运算与类型转换

---

## 第十四章

### 基本概念

- 当一个重载运算符是成员函数时，this绑定到左侧运算对象。成员运算符的(显式)参数数量比运算对象的数量少一个。

- 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。不能重载的运算符，::，.*，., ?:。

- 通常情况下，不应该重载逗号(无法保证求值顺序)、取地址、逻辑与(无法利用短路)、逻辑或(无法利用短路)运算符

- 成员函数or非成员函数
   - 赋值(=)、下标([])、调用(())和成员访问箭头(->)运算符必须是成员。
   - 复合赋值运算符一般来说是成员，但并非必须，这一点与赋值运算符略有不同。
   - 改变对象状态的运算符或者与给定类型密切的运算符，如递增、递减和解引用运算符，通常应该是成员。
   - 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符，因此它们应该是普通的非成员函数。

### 输入和输出运算符

- 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。

- 输入输出运算符必须是非成员函数。IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。

- 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。
```c++
istream& operator<<(istream& is,Sales_data& item)
{
    double price;
    is >> item.bookNo >> item.units_sold >> price;
    if(is)
    {
        item.revenue = item.units_sold*price;
    }
    else
    {
        item = Sales_data();
    }
}
```

### 算术和关系运算符

- 通常情况下，会把算术和关系运算符定义成非成员函数以允许对左侧或者右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参通常都是常量引用。

- 如果类同时定义了算术运算符和相关的复合赋值运算符，通常情况下应该使用复合赋值来实现算术运算符。

- 如果类定义了operator==，则这个类也应该定义operator!=。

- 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和==产生的结果一致时才定义<运算符。

- 如果重载赋值运算符，则无论形参的类型是什么，赋值运算都必须定义为成员函数。复合赋值运算符也应该定义为类的成员，这两类运算符都返回左侧运算对象的引用。

- 下标运算符必须是成员函数。

- 如果一个类包含下标运算符，通常要定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用。
```c++
class StrVec
{
public:
    std::string& operator[](std::size_t n)
    {
        return elements[n];
    }
    const std::string& operator[](std::size_t n) const
    {
        return elements[n];
    }
private:
    std::string* elements;
};
```

- 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常被定义为类成员。
```c++
class StrBlobPrt
{
public:
    //前置版本，应该返回递增或者递减之后对象的引用
    StrBlobPtr& operator++();
    StrBlobPtr& operator--()；
    //后置版本，返回的是一个值而非引用。int类型的形参，这个形参的唯一作用就是区别前置版本和后置版本的函数，不会用到int参数，无需为其命名。
    StrBlobPtr operator++(int);
    StrBlobPtr operator--(int)；
};
```
显式的调用前置/后置递加/递减运算符，则方法如下：
```c++
StrBlobPtr p(al);
p.operator++(0);//调用后置版本的operator++
p.operator++();//调用前置版本的operator++
```

- 箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。

- 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。

### 函数调用运算符

- 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。

- 接下来是14.8.2