---
layout: post
title: C++ Primer 第十九章
categories: C++
description: C++ Primer
keywords: C++, Primer
---

特殊工具与技术

---

## 第十九章

### 运行时类型识别

- 运行时类型识别(run-time type identification,RTTI)的功能由两个运算符实现：1、typeid运算符，用于返回表达式的类型；2、dynamic_cast运算符，用于将基类的指针或者引用安全地转换成派生类的指针或引用。

当我们将这两个运算符用于某种类型的指针或者引用，并且该类型含有虚函数时，运算符将使用指针活引用所绑定对象的动态类型。

- 使用RTTI必须加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。

- dynamic_cast运算符的使用形式如下：
```c++
//以下type必须是类类型
dynamic_cast<type*>(e);//e是有效指针
dynamic_cast<type&>(e);//e必须是左值
dynamic_cast<type&&>(e);//e不能是左值
```
e的类型可能是：目标type的公有派生类、目标type的公有基类、目标type的类型。

- 如果一条dynamic_cast语句的转化目标是指针类型并且失败了，则结果为0.如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast异常。

- 可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。

- 在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一个条表达式中完成。
```c++
if (Derived *dp = dynamic_cast<Derived*>(bp))
{
    //使用dp指向的Derived对象
}
else//bp指向一个Base对象
{
    //使用bp指向的Base对象
}
```

- typeid运算符，返回对象的类型。使用方式typeid(e)，其中e是任意表达式或者类型的名字。typeid操作结果是一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型。type_info类定义在typeinfo头文件中。typeid忽略顶层const，但是不会执行数组向指针的标准类型转换。当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得。

- 当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态编译时类型。

- 如果p是一个空指针，则typeid(*p)将抛出一个名为bad_typeid的异常。

- type_info类必须定义在typeinfo类中。type_info类没有默认构造函数，而且它的拷贝和移动构造函数以及赋值运算符都被定义为删除的。无法定义或者拷贝type_info类型的对象，也不能为type_info类型的对象赋值。创建type_info对象的唯一途径就是使用typeid运算符。

- type_info类在不同的编译器上有所不同。有的编译器提供了额外的成员函数以提供程序中所有类型的额外信息。

### 枚举类型

- 枚举类型属于字面值常量类型。C++枚举有两种：限定作用域和不限定作用域的。C++11新标准引入了限定作用域的枚举类型。

- 限定作用域的枚举类型：首先是关键字enum class(或者 enum struct)，随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员，最后是一个分号：
```c++
enum class open_modes {input,output,append};
```
限定作用域的枚举，在引用的使用必须加上域限定符。

- 不限定作用域的枚举类型：
```c++
enum color {red,yellow,green};//不限定作用域的枚举类型
enum {floatPrec = 6,doublePrec = 10,double_doublePrec = 10};//未命名的、不限定作用域的枚举类型。

- 默认情况下，枚举值从0开始，依次加1。如果没有显式地提供初始值，则当前枚举成员的值等于之前枚举成员的值加1。

- 枚举成员是const，初始化时提供的初始值必须是常量表达式。一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整形，而限定作用域的不行。

- C++11中，可以在enum的名字后加上冒号以及我们想在该enum中使用的类型：
```c++
enum intValues: unsigned long long {
    charTyp = 255, shortTyp = 65535, longTyp = 429512131UL
}
```
如果没有显式的指定enum的潜在类型，则默认情况下限定作用域的enum成员类型是int。对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，但是潜在类型足够大，能够容纳枚举值。

- C++11中允许enum的前置声明。enum前置声明必须指定其成员的大小：
```c++
enum intValue: unsigned long long;//不限定作用域，必须指定成员类型
enum class open_modes;//限定作用域的枚举类型可以使用默认成员类型int
```

- 要想初始化一个enum对象，必须使用该enum类型的另一个对象或者它的一个枚举成员。因此，即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的enum实参类型。

### 类成员指针

### 嵌套类

- 一个类可以定义在另一个类的内部，前者称为嵌套类或者嵌套类型。嵌套类是一个独立的类，与外层类基本没有什么关系。外层类的对象和嵌套类的对象是相互独立的。外层类的对象和嵌套类的对象是相互独立的。在嵌套类的对象中不包含任何外层类定义的成员；类似的，在外层类的对象中也不包含任何嵌套类定义的成员。

- 嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。嵌套类的名字不会和别的作用域中的同一个名字冲突。

### union：一种节省空间的类









